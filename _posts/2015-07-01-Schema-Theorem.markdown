---
layout:     post
title:      "模式定理"
date:       2015-07-01
author:     "K"
header-img: "img/post-bg-adaptive population sizing schemes.jpg"
tags:
    - Study
---


> 会玩的人才会学。  —— 张璐（2008年陕西省高考文科状元）


## 目录

1.  [基本概念](#section-1)
2.  [模式定理](#section-2)<br>
  2.1.  [复制时的模式数目](#section-3)<br>
  2.2.  [交叉时的模式数目](#section-4)<br>
  2.3.  [变异时的模式数目](#section-5)<br>
  2.4.  [模式定理](#section-6)<br>
  2.5.  [建筑块假说](#section-7)<br>
3.  [隐含并行性](#section-8)<br>


## 基本概念

**问题引入：**
求解方程 F(x) = x^2 在[0,31]上的最大值，使用固定长度二进制编码对种群中的个体进行编码，在计算适应度值时会发现一个规律，当个体编码的最左边为1时，适应度普遍较大，可以记为“1\*\*\*1”，同理“0\*\*\*\*”的个体适应度偏低。由此可以引入以下一些基本概念：

**模式(Schema)：**编码的字符串中具有类似特征的子集。
例如上述五位二进制字符串中，模式“\*111\*”可代表4个个体。个体和模式的一个区别就是，个体是由{0，1}组成的编码串，模式是由{0，1，*}组成，‘\*’为通配符。

**模式阶(Schema Order)：**表示模式中已有明确含义的字符个数，记为o(s)，s代表模式。例如o(\*111\*)=3;
阶数越低，说明模式的概括性越强，所代表的编码串个体数也越多。其中阶数为零的模式概括性最强。

**模式定义长度(Schema Defining Length)**：指第一个和最后一个具有含义的字符之间的距离，其可表示该模式在今后遗传操作中被破坏的可能性，越短则越小，长度为0最难被破坏。

**模式数目：**
在二进制字符串中，假设字符长度为 λ，字符串中每一个字符可取(0,1,*)三个符号中任意一个，则可能组成的模式数目最多是 3^λ，扩展为一般情况，单个字符的取值有 k 种，则字符串组成的模式数目 n 为 (k+1)^λ。

**编码字符串（一个个体编码串）所含模式总数：**
在二进制字符串中，假设字符长度为 λ，则可能组成的模式数目最多是 2^λ。因为每个个体编码串均已有数字，只能在既定值和‘*’之间选择。扩展为一般情况，单个字符的取值有 k 种，则字符串组成的模式数目 n 为 k^λ。

**群体所含模式数：**
在长度为 λ 规模为 M 的二进制编码字符串群体中，一般含有 2^λ ~ M*2^λ 个模式。

## 模式定理
在引入模式的概念后，GA 的实质可看作是对模式的一种运算。对基本遗传算法而言，也就是某一模式s的各个样本经过选择运算、交叉运算、变异运算之后，得到一些新的样本和新的模式。


#### 复制时的模式数目

这里以比例选择算子为例研究

![alt text](/img/in-post/Schema-Theorem/schema  theory1.png)

由以上过程可知，复制后下一代群体中属于模式 s 的个体数目，取决于该模式的平均适应度与群体的平均适应度之比。只有当该模式的平均值大于群体的平均值时，s 模式的个体数目才能增长，否则，s 模式要减少。而这种增减规律正好符合“优胜劣汰”原则，这也说明模式的确能描述字符串的内部特征。

![alt text](/img/in-post/Schema-Theorem/schema  theory2.PNG)

进一步分析可得上述指数方程，说明模式 s 所拥有的个体数目在复制过程中以指数形式增加或减少。

#### 交叉时的模式数目

这里以单点交叉算子为例研究

有两个模式 **s1：**“\* 1 \* \* \* \* 0”，**s2：**“\* \* \* 1 0 \* \*”，它们有一个共同的可匹配的个体 a：“0 1 1 1 0 0 0”
选择个体 a 进行交叉，随机选择交叉点
  **s1：**“\* 1 \* \* \* \* 0”  交叉点选在第 2 ~ 6 之间都可能破坏模式 s1;
  **s2：**“\* \* \* 1 0 \* \*”  交叉点选在第 4 ~ 5 之间才可能破坏模式 s2。
![alt text](/img/in-post/Schema-Theorem/schema  theory3.PNG)由上述分析可知模式的定义长度对模式的存亡影响很大，模式的长度越大，越容易被破坏。

#### 变异时的模式数目

这里以基本位变异算子为例研究。

![alt text](/img/in-post/Schema-Theorem/schema  theory4.PNG)上式说明，模式的阶次o(s)越低，模式s 存活的可能性越大，反之亦然。

#### 模式定理

综合式以上三步可以得出遗传算法经复制、交叉、变异操作后，模式s在下一代群体中所拥有的个体数目，如下式所示：
![alt text](/img/in-post/Schema-Theorem/schema  theory5.PNG)


**模式定理：**   适应度高于群体平均适应度的，长度较短，低阶的模式在遗传算法的迭代过程中将按指数规律增长。该定理深刻地阐明了遗传算法中发生“优胜劣汰”的原因。在遗传过程中能存活的模式都是定义长度短、阶次低、平均适应度高于群体平均适应度的优良模式。遗传算法正是利用这些优良模式逐步进化到最优解。


模式能够划分搜索空间，而且模式的阶越高，对搜索空间的划分越细致。模式定理告诉我们：GA 根据模式的适应度、长度和阶次为模式分配搜索次数。为那些适应度较高，长度较短，阶次较低的模式分配的搜索次数按指数率增长；为那些适应度较低，长度较长，阶次较高的模式分配的搜索次数按指数率衰减。

#### 建筑块假说

**建筑块（或称积木块）即 Buliding Block** 定义为短定义长度、低阶、高适应度的模式。
之所以称之为建筑块（积木块），是由于遗传算法的求解过程并不是在搜索空间中逐一地测试各个基因的枚举组合，而是通过一些较好的模式，像搭积木一样、将它们拼接在一起，从而逐渐地构造出适应度越来越高的个体编码串。

**建筑块假说**
GA 在搜索过程中将不同的“建筑块”通过遗传算子（如交叉算子）的作用结合在一起，形成适应度更高的新模式。这样将大大缩小 GA 的搜索范围。

**建筑块混合**
建筑块通过遗传算子的作用集合在一起的过程称为“建筑块混合”。当那些构成最优点（或近似最优点）的“建筑块”结合在一起时，就得到了最优点。例如问题的最优用三个建筑块 BB1, BB2, BB3 表示，初始种群个有三个个体分别拥有这三个 BB，则经过几代后产生了同时拥有这三个 BB 的个体，即位最优解。

## 隐含并行性
隐含并行性又称内在并行性(Implicit Parallelism)，是模式理论的另一个重要内容。这一机理说明，在遗传算法中尽管每一代只处理 M 个个体，但实际上却是处理了 M3 以上的模式。

**隐含并行性定理**
![alt text](/img/in-post/Schema-Theorem/schema  theory6.PNG)以二进制编码为例。在长度为l，规模为M的群体中，包含了 2l ~ M·2l 个不 
同的模式，随着进化过程的进行，这些模式中一些定义长度较长的模式被破坏掉，而另一些定义长度较短的模式却能够生存下来。
![alt text](/img/in-post/Schema-Theorem/schema  theory7.PNG)![alt text](/img/in-post/Schema-Theorem/schema  theory8.PNG)![alt text](/img/in-post/Schema-Theorem/schema  theory9.PNG)![alt text](/img/in-post/Schema-Theorem/schema  theory10.PNG)

**结论**
遗传算法所处理的有效模式总数约与群体规模M的立方成正比。也就是说，虽然在进化过程的每一代中只处理了M个个体，但实际上我们并行处理了与M的立方成正比例的模式数。
因此，遗传算法实际上是一种并行算法，隐藏在个体的背后，故称隐含并行算法。正是由于这种隐含并行性，遗传算法的搜索效率很高。

> 参考：<br>
> [Holland's schema theorem From Wikipedia](https://en.wikipedia.org/wiki/Holland%27s_schema_theorem) <br>
> [Holland's schema theorem From cse.unr.edu](http://www.cse.unr.edu/~sushil/class/gas/notes/GASchemaTheorem2.pdf) <br>
> [Introduction to Schema Theory From George Mason University](http://cs.gmu.edu/~eclab/papers/lecture-pres/schema.pdf) <br>
