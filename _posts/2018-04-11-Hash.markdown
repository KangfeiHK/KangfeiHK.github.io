---
layout:     post
title:      "散列表"
date:       2018-04-11
author:     "K"
header-img: "img/post-bg-markdown.jpg"
tags:
    - 数据结构
---


散列表，也称哈希表（Hash Table），关键码值Key经过散列函数H的计算，得到Value为元素在表中的存储位置(散列地址)。检索时用同样的方式计算，然后得到相应的地址，即可实现快速检索。

哈希表的实现需要解决两个问题：
1. 如何构造合适的散列函数？
2. 如何解决冲突问题？

## 散列函数

理想的散列函数应该具备计算简单性，以及同一性（输出尽量分布均匀）。常用的散列函数如下：

1. 除余法
对于散列表长为m的散列函数公式为： f(key) = key mod p (p <= m)
其中p 的选择很重要，若散列表表长为m，通常p为小于或者等于表长（最好接近m）的最小质数。

2. 直接定址法/直接寻址法
取关键字或关键字的某个线性函数作为散列地址。

3. 数学分析法
假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。

4. 平方取中法
取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。


## 冲突解决

散列函数设计应尽量减小冲突的可能性，但是现实中仍旧无法避免产生“碰撞”（也称为冲突，collision），即两个不同的关键词输出同样的散列地址。因此我们需要拟定解决冲突的方案。

冲突解决策略可以分为开散列法（Open Hashing，Separate Chaining）和闭散列法（Closed Hashing，Open Addressing)。 Here "open" refers to the freedom we get by leaving the hash table, and using a separate list. By the way, "separate list" hints at why open hashing is also known as "separate chaining". In short, "closed" always refers to some sort of strict guarantee, like when we guarantee that objects are always stored directly within the hash table (closed hashing). Then, the opposite of "closed" is "open", so if you don't have such guarantees, the strategy is considered "open".（[Stackoverflow](https://stackoverflow.com/questions/9124331/meaning-of-open-hashing-and-closed-hashing)）

其中开散列法中最重要的就是链地址法，将所有散列地址相同的元素链接在同一个单链表中，并将单链的头指针存储在表头。

闭散列法也就是开放定址法，将所有元素存储在散列表中，一旦出现冲突，使用某种策略重新生成散列地址。常用的有以下几种：

1. 线性探测法，冲突发生时，顺序查看表中下一个单元，直到找到下一个空单元。
2. 二次探测法，将冲突地址依次按照 1^2, 2^2… 在两侧进行移动，直到找到下一个空位。
3. 伪随机探测，将伪随机序列中的数字依次带入进行计算，直到找到下一个空位。

在线性探测和二次探测法中，散列函数的结果不均匀地占据表的单元，容易形成区块，产生聚集现象，导致更大的平均检索长度，导致散列表的性能。

再哈希法：即在上次散列计算发生冲突时，利用该次冲突的散列函数地址产生新的散列函数地址，直到冲突不再发生。这种方法不易产生“聚集”（Cluster），但增加了计算时间。


## 散列表分析

对散列表查找效率的量度，依然用平均查找长度来衡量。查找长度直接取决于冲突的多少，影响产生冲突有以下三个因素：
1. 散列函数是否均匀；
2. 处理冲突的方法；
3. 散列表的载荷因子。

链地址法与开放定址法相比优点如下：
1. 链地址法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
2. 对于开放定址法，荷载因子是特别重要因素，应严格限制在0.7-0.8以下（为减少冲突）。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升。因此，一些采用开放定址法的hash库，如Java的系统库限制了荷载因子为0.75，超过此值将resize散列表。
3. 随着装填因子的增大，用开哈希法解决冲突，其平均搜索长度比用闭哈希法解决时的平均长度增长得慢。因为开哈希法只会和相同值发生冲突，而闭哈希法还会与不同值发生冲突
4. 在用链地址法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

缺点：
指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。


## Reference

- [哈希、HashMap原理及源码、Hash的一些应用面试题](http://www.voidcn.com/article/p-cutwphsv-oz.html)
- [散列冲突处理：链地址法](http://www.nowamagic.net/academy/detail/3008060)


